/*********************                                                        */
/*! \file eq_proof.h
 ** \verbatim
 ** Top contributors (to current version):
 **   Haniel Barbosa, Andrew Reynolds
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2020 by the authors listed in the file AUTHORS
 ** in the top-level source directory) and their institutional affiliations.
 ** All rights reserved.  See the file COPYING in the top-level source
 ** directory for licensing information.\endverbatim
 **
 ** \brief Implementation of a proof as produced by the equality engine.
 **
 **/

#include "theory/uf/eq_proof.h"

namespace CVC4 {
namespace theory {
namespace eq {

void EqProof::debug_print(const char* c,
                          unsigned tb,
                          PrettyPrinter* prettyPrinter) const
{
  std::stringstream ss;
  debug_print(ss, tb, prettyPrinter);
  Debug(c) << ss.str();
}
void EqProof::debug_print(std::ostream& os,
                          unsigned tb,
                          PrettyPrinter* prettyPrinter) const
{
  for (unsigned i = 0; i < tb; i++)
  {
    os << "  ";
  }

  if (prettyPrinter)
  {
    os << prettyPrinter->printTag(d_id);
  }
  else
  {
    os << static_cast<MergeReasonType>(d_id);
  }
  os << "(";
  if (d_children.empty() && d_node.isNull())
  {
    os << ")";
    return;
  }
  if (!d_node.isNull())
  {
    os << std::endl;
    for (unsigned i = 0; i < tb + 1; ++i)
    {
      os << "  ";
    }
    os << d_node << (!d_children.empty() ? "," : "");
  }
  unsigned size = d_children.size();
  for (unsigned i = 0; i < size; ++i)
  {
    os << std::endl;
    d_children[i]->debug_print(os, tb + 1, prettyPrinter);
    if (i < size - 1)
    {
      for (unsigned j = 0; j < tb + 1; ++j)
      {
        os << "  ";
      }
      os << ",";
    }
  }
  if (size > 0)
  {
    for (unsigned i = 0; i < tb; ++i)
    {
      os << "  ";
    }
  }
  os << ")" << std::endl;
}

void EqProof::maybeFoldTransitivityChildren(std::vector<Node>& premises,
                                            CDProof* p) const
{
  // traverse premises to see if any of the form (= (= t1 t2) false)
  unsigned size = premises.size();
  unsigned termPos, offending = size;
  for (unsigned i = 0; i < size; ++i)
  {
    Assert(premises[i].getKind() == kind::EQUAL);
    for (unsigned j = 0; j < 2; ++j)
    {
      if (premises[i][j].getKind() == kind::CONST_BOOLEAN
          && !premises[i][j].getConst<bool>()
          && premises[i][1 - j].getKind() == kind::EQUAL)
      {
        // there is only one offending equality
        Assert(offending == size);
        offending = i;
        termPos = 1 - j;
        break;
      }
    }
  }
  // if no equality of the searched form, nothing to do
  if (offending == size)
  {
    return;
  }
  Debug("eqproof::conv") << "EqProof::maybeFoldTransitivityChildren: found "
                            "offending equality at index "
                         << offending << " : " << premises[offending] << "\n";
  Debug("eqproof::conv")
      << "EqProof::maybeFoldTransitivityChildren: look for savior "
      << premises[offending][termPos] << " in premises " << premises << "\n";
  // given the offending equality (= (= t1 t2) false), check if there is any
  // equality of the form (= t1 t2) among the other premises
  unsigned savior = size;
  for (unsigned i = 0; i < size; ++i)
  {
    if (i != offending
        && (premises[offending][termPos] == premises[i]
            || premises[offending][termPos] == premises[i][0]
            || premises[offending][termPos] == premises[i][1]))
    {
      savior = i;
      break;
    }
  }
  // if there is an equality of the searched form, nothing to do, the regular
  // transitivity handling can deal with these premises
  if (savior != size)
  {
    Debug("eqproof::conv")
        << "EqProof::maybeFoldTransitivityChildren: found savior at index "
        << savior << " : " << premises[savior] << "\n";
    return;
  }
  Debug("eqproof::conv") << "EqProof::maybeFoldTransitivityChildren: did not "
                            "find a savior\n";
  // if there is no savior, it has to be generated by another application of the
  // transtivity rule, which will reason at the level of the equalities between
  // the terms, not the equality between equalities and a boolean constant
  Node conclusion = premises[offending][termPos];
  std::vector<Node> foldPremises;
  for (unsigned i = 0; i < size; ++i)
  {
    if (i != offending)
    {
      foldPremises.push_back(premises[i]);
    }
  }
  Debug("eqproof::conv") << "EqProof::maybeFoldTransitivityChildren: gonna "
                            "build a transitivity step for conclusion "
                         << conclusion << " with premises " << foldPremises
                         << "\n";
  unsigned newSize = foldPremises.size();
  maybeAddSymmOrTrueIntroToProof(0, foldPremises, true, conclusion[0], p);
  for (unsigned i = 1; i < newSize - 1; ++i)
  {
    maybeAddSymmOrTrueIntroToProof(
        i, foldPremises, true, foldPremises[i - 1][1], p);
  }
  maybeAddSymmOrTrueIntroToProof(
      newSize - 1, foldPremises, false, conclusion[1], p);
  // create folding step
  if (!p->addStep(conclusion, PfRule::TRANS, foldPremises, {}, true))
  {
    Assert(false) << "EqProof::maybeFoldTransitivityChildren: couldn't add "
                     "folding trans step\n";
  }
  // generate new premises: offending equality and the generated savior
  std::vector<Node> newPremises{conclusion, premises[offending]};
  premises.clear();
  premises.insert(premises.begin(), newPremises.begin(), newPremises.end());
}

void EqProof::maybeAddSymmOrTrueIntroToProof(unsigned i,
                                             std::vector<Node>& premises,
                                             bool first,
                                             Node termInEq,
                                             CDProof* p) const
{
  // nothing to do
  if (premises[i][first ? 0 : 1] == termInEq)
  {
    return;
  }
  NodeManager* nm = NodeManager::currentNM();
  Debug("eqproof::conv")
      << "EqProof::maybeAddSymmOrTrueIntroToProof: seach for " << termInEq
      << " as " << (first ? "fst" : "snd") << " term starting in index " << i
      << " in " << premises << "\n";
  // look for first premise with termInEq in it. If j != i, move that
  // premise to the position i of the list
  unsigned j, size = premises.size();
  bool correctlyOrdered = false;
  for (j = i; j < size; ++j)
  {
    bool occurs = false;
    if (termInEq == premises[j][first ? 0 : 1])
    {
      occurs = correctlyOrdered = true;
    }
    else if (termInEq == premises[j][first ? 1 : 0])
    {
      occurs = true;
    }
    if (occurs)
    {
      Debug("eqproof::conv")
          << "EqProof::maybeAddSymmOrTrueIntroToProof: found termInEq "
          << termInEq << " in premise " << j << "\n";
      if (j != i)
      {
        // move premise to position i.
        Node premise = premises[j];
        premises.erase(premises.begin() + j);
        premises.insert(premises.begin() + i, premise);
        Debug("eqproof::conv")
            << "EqProof::maybeAddSymmOrTrueIntroToProof: reordering premises: "
            << premises << "\n";
      }
      break;
    }
  }
  // did not find it. It must be the case that termInEq is a boolean
  // constant and a TRUE_INTRO step is applied
  if (j == size)
  {
    Assert(termInEq.getKind() == kind::CONST_BOOLEAN
           && termInEq.getConst<bool>())
        << "term " << termInEq
        << " is not True, so it should have been in a premise\n";
    // add TRUE_INTRO step for first premise
    Node conclusion = premises[i].eqNode(nm->mkConst<bool>(true));
    Debug("eqproof::conv") << "EqProof::maybeAddSymmOrTrueIntroToProof: adding "
                           << PfRule::TRUE_INTRO << " step for " << premises[i]
                           << "\n";
    if (!p->addStep(conclusion, PfRule::TRUE_INTRO, {premises[i]}, {}))
    {
      Assert(false) << "EqProof::maybeAddSymmOrTrueIntroToProof: couldn't add "
                    << PfRule::TRUE_INTRO << " rule\n";
    }
    premises[i] = conclusion;
    // not correctly ordered unless I'm looking for TRUE as the second argument
    correctlyOrdered = !first;
  }
  // no need to reorder
  if (correctlyOrdered)
  {
    return;
  }
  // reorder
  std::vector<Node> symmChildren{premises[i]};
  Debug("eqproof::conv") << "EqProof::maybeAddSymmOrTrueIntroToProof: adding "
                         << PfRule::SYMM << " step for " << premises[i] << "\n";
  Node symmChild = nm->mkNode(kind::EQUAL, premises[i][1], premises[i][0]);
  if (!p->addStep(symmChild, PfRule::SYMM, symmChildren, {}))
  {
    Assert(false) << "EqProof::maybeAddSymmOrTrueIntroToProof: couldn't add "
                  << PfRule::SYMM << " rule\n";
  }
  premises[i] = symmChild;
}

Node EqProof::addToProof(CDProof* p) const
{
  // assumption
  if (d_id == MERGED_THROUGH_EQUALITY)
  {
    Debug("eqproof::conv") << "EqProof::addToProof: adding assumption step for "
                           << d_node << "\n";
    std::vector<Node> children;
    std::vector<Node> args{d_node};
    if (!p->addStep(d_node, PfRule::ASSUME, children, args))
    {
      Assert(false) << "EqProof::addToProof: couldn't add assupmtion\n";
    }
    // if non-equality predicate, turn into one via TRUE/FALSE intro
    Node conclusion = d_node;
    if (d_node.getKind() != kind::EQUAL)
    {
      Assert(children.empty());
      children.push_back(d_node);
      PfRule intro;
      if (d_node.getKind() == kind::NOT)
      {
        conclusion =
            d_node[0].eqNode(NodeManager::currentNM()->mkConst<bool>(false));
        intro = PfRule::FALSE_INTRO;
      }
      else
      {
        intro = PfRule::TRUE_INTRO;
        conclusion =
            d_node.eqNode(NodeManager::currentNM()->mkConst<bool>(true));
      }
      Debug("eqproof::conv") << "EqProof::addToProof: adding " << intro
                             << " step for " << d_node << "\n";
      if (!p->addStep(conclusion, intro, children, {}))
      {
        Assert(false) << "EqProof::addToProof: couldn't add " << intro
                      << " rule\n";
      }
    }
    return conclusion;
  }
  // refl
  if (d_id == MERGED_THROUGH_REFLEXIVITY)
  {
    Debug("eqproof::conv") << "EqProof::addToProof: adding refl step for "
                           << d_node << "\n";
    std::vector<Node> children;
    std::vector<Node> args{d_node};
    Node conclusion = d_node.eqNode(d_node);
    if (!p->addStep(conclusion, PfRule::REFL, children, args))
    {
      Assert(false) << "EqProof::addToProof: couldn't add refl step\n";
    }
    return conclusion;
  }
  // can support case of negative merged throgh constants, but not positive one
  // yet
  if (d_id == MERGED_THROUGH_CONSTANTS)
  {
    Assert(false) << "Unsupported rule: " << d_id << "\n";
    return d_node;
  }
  if (d_id == MERGED_THROUGH_TRANS)
  {
    Debug("eqproof::conv") << "EqProof::addToProof: adding trans step for "
                           << d_node << "\n";
    std::vector<Node> children;
    for (unsigned i = 0, size = d_children.size(); i < size; ++i)
    {
      // if one of the steps is a fake congruence one, it must deleted. Its
      // premises are moved down to premises of the transitivity step
      EqProof* childProof = d_children[i].get();
      if (childProof->d_id == MERGED_THROUGH_CONGRUENCE
          && childProof->d_node.isNull())
      {
        bool addedChild = false;
        Debug("eqproof::conv") << "EqProof::addToProof: child proof " << i
                               << " is fake cong step. Fold it.\n";
        Assert(childProof->d_children.size() == 2);
        Debug("eqproof::conv")
            << push << "EqProof::addToProof: recurse on child 0\n"
            << push;
        Node child = childProof->d_children[0].get()->addToProof(p);
        // ignore reflexivity
        if (child[0] != child[1])
        {
          children.push_back(child);
          addedChild = true;
        }
        Debug("eqproof::conv")
            << pop << "EqProof::addToProof: recurse on child 1\n"
            << push;
        child = childProof->d_children[1].get()->addToProof(p);
        // ignore reflexivity
        // ignore reflexivity
        if (child[0] != child[1])
        {
          children.push_back(child);
          addedChild = true;
        }
        Debug("eqproof::conv") << pop << pop;
        Assert(addedChild);
        continue;
      }
      Debug("eqproof::conv")
          << "EqProof::addToProof: recurse on child " << i << "\n"
          << push;
      children.push_back(childProof->addToProof(p));
      Debug("eqproof::conv") << pop;
    }
    // if premises contain one equality between false and an equality then maybe
    // it'll be necessary to fix the transitivity premises before reaching the
    // original conclusion. For example
    //
    //  (= t1 t2) (= t3 t2) (= (t1 t3) false)
    //  ------------------------------------- TRANS
    //             false = true
    //
    // must, before the processing below, become
    //
    //            (= t3 t2)
    //            --------- SYMM
    //  (= t1 t2) (= t2 t3)
    //  ------------------- TRANS
    //       (= t1 t3)             (= (t1 t3) false)
    //  --------------------------------------------- TRANS
    //             false = true
    //
    // Note this method may change children, so afterwards don't rely on
    // assumptions previous to this call
    maybeFoldTransitivityChildren(children, p);
    Debug("eqproof::conv")
        << "EqProof::addToProof: maybe reorder trans premises " << children
        << "\n";
    // conclusion is t1 = tn. Children MUST BE (= t1 t2), ..., (= t{n-1} tn). If
    // t1 or tn are true or false, then premises may have to be amended with
    // TRUE/FALSE intro rules. Process children to ensure this
    unsigned size = children.size();
    maybeAddSymmOrTrueIntroToProof(0, children, true, d_node[0], p);
    for (unsigned i = 1; i < size - 1; ++i)
    {
      Assert(children[i - 1].getKind() == kind::EQUAL);
      maybeAddSymmOrTrueIntroToProof(i, children, true, children[i - 1][1], p);
    }
    maybeAddSymmOrTrueIntroToProof(size - 1, children, false, d_node[1], p);
    // add step while making sure that all children have been added to the proof
    if (!p->addStep(d_node, PfRule::TRANS, children, {}, true))
    {
      Assert(false) << "EqProof::addToProof: couldn't add trans step\n";
    }
    Node conclusion = d_node;
    // If t1 = tn is of the form (= t true/false), in which t is not true/false,
    // it must be turned into t or (not t) with TRUE/FALSE_ELIM.
    if (d_node.getKind() == kind::EQUAL
        && ((d_node[0].getKind() == kind::CONST_BOOLEAN
             && d_node[1].getKind() != kind::CONST_BOOLEAN)
            || (d_node[1].getKind() == kind::CONST_BOOLEAN
                && d_node[0].getKind() != kind::CONST_BOOLEAN)))
    {
      std::vector<Node> elimChildren{d_node};
      unsigned constIndex = d_node[0].getKind() == kind::CONST_BOOLEAN ? 0 : 1;
      PfRule elim;
      if (d_node[1 - constIndex].getConst<bool>())
      {
        elim = PfRule::TRUE_ELIM;
      }
      else
      {
        elim = PfRule::FALSE_ELIM;
        conclusion = d_node[1 - constIndex].notNode();
      }
      Debug("eqproof::conv") << "EqProof::addToProof: adding " << elim
                             << " step for " << d_node << "\n";
      if (!p->addStep(conclusion, elim, elimChildren, {}))
      {
        Assert(false) << "EqProof::addToProof: couldn't add " << elim
                      << " rule\n";
      }
    }
    return conclusion;
  }
  Assert(d_id == MERGED_THROUGH_CONGRUENCE);
  Debug("eqproof::conv") << "EqProof::addToProof: adding cong step for "
                         << d_node << "\n";
  // congruence steps must be flattened (since it assumes currying) and the
  // conclusion must be reconstructed (since only one of the terms is
  // represented)
  NodeManager* nm = NodeManager::currentNM();
  std::vector<Node> args;
  Assert(d_node.getKind() == kind::APPLY_UF
         || d_node.getKind() == kind::PARTIAL_APPLY_UF);
  args.push_back(d_node.getOperator());
  // The given conclusion, d_node, is either the LHS or the RHS or the intended
  // equality. We reconstruct both below and later do a sanity check that d_node
  // corresponds to one of them
  std::vector<Node> conclusionLhsArgs;
  std::vector<Node> conclusionRhsArgs;
  std::vector<Node> children;
  const EqProof* childProof = this;
  // iterate over children proofs. first child proof is always bogus
  for (unsigned i = 0, arity = d_node.getNumChildren(); i < arity; ++i)
  {
    Assert(childProof->d_children.size() == 2);
    Debug("eqproof::conv") << "EqProof::addToProof: recurse on second child of "
                           << i << "-th cong\n"
                           << push;
    children.insert(children.begin(),
                    childProof->d_children[1].get()->addToProof(p));
    Assert(children[0].getKind() == kind::EQUAL);
    conclusionLhsArgs.insert(conclusionLhsArgs.begin(), children[0][0]);
    conclusionRhsArgs.insert(conclusionRhsArgs.begin(), children[0][1]);
    Debug("eqproof::conv") << pop;
    if (i < arity - 1)
    {
      Assert(childProof->d_children[0].get()->d_id
             == MERGED_THROUGH_CONGRUENCE);
      childProof = childProof->d_children[0].get();
    }
    else
    {
      // case of f = f
      Assert(childProof->d_children[0].get()->d_id
             == MERGED_THROUGH_REFLEXIVITY);
    }
  }
  // add operator
  conclusionLhsArgs.insert(conclusionLhsArgs.begin(), args[0]);
  conclusionRhsArgs.insert(conclusionRhsArgs.begin(), args[0]);
  // build conclusion
  Node conclusion = nm->mkNode(kind::EQUAL,
                               nm->mkNode(kind::APPLY_UF, conclusionLhsArgs),
                               nm->mkNode(kind::APPLY_UF, conclusionRhsArgs));
#ifdef CVC4_ASSERTIONS
  // d_node, if non-null, modulo PARTIAL_APPLY_UF for unary cases, must be the
  // same as either the LHS or the RHS of the new conclusion
  Node originalConclusion = d_node;
  if (d_node.getKind() == kind::PARTIAL_APPLY_UF)
  {
    Assert(d_node.getNumChildren() == 1);
    std::vector<Node> appArgs{args[0], d_node[0]};
    originalConclusion = nm->mkNode(kind::APPLY_UF, appArgs);
  }
  Assert(originalConclusion == conclusion[0]
         || originalConclusion == conclusion[1]);
#endif
  if (!p->addStep(conclusion, PfRule::CONG, children, args, true))
  {
    Assert(false) << "EqProof::addToProof: couldn't add cong step\n";
  }
  if (Debug.isOn("eqproof::conv"))
  {
    Debug("eqproof::conv") << "EqProof::addToProof: proof node of "
                           << conclusion << " is:\n";
    std::stringstream out;
    p->getProof(conclusion).get()->printDebug(out);
    Debug("eqproof::conv") << out.str() << "\n";
  }
  return conclusion;
}

}  // namespace eq
}  // Namespace theory
}  // Namespace CVC4
